BOT DETECTION SYSTEM - PROJECT OVERVIEW

===============================================

PROBLEM STATEMENT

Login and registration endpoints were getting hammered by automated bots with too many requests.
Database load was increasing and legitimate users were facing issues.
We needed a simple, effective solution without overcomplicating things.

===============================================

TECH STACK AND WHY

Backend:
  Node.js + Express - Already using this, no need to add complexity
  MongoDB - Existing DB, added RequestLog model for tracking
  JWT - Current auth system, no changes needed
  bcrypt - Password hashing (already in place)

Frontend:
  React 18 - Main framework
  Axios - API calls (already used in project)
  Custom hooks - Keeps code clean, reusable

Why no fancy libraries?
  No Redux/MobX - Simple form state doesn't need it
  No rate-limit-redis initially - In-memory works fine for our scale
  No ML/AI scoring - Rule-based scoring is faster and easier to debug

===============================================

PLANNING PHASE

Initial Requirements:
  1. Detect bot-like behavior on critical endpoints (login, register)
  2. Don't block legitimate users accidentally
  3. Must be easy to monitor and adjust thresholds
  4. Should work with existing codebase without major refactoring

Decision: Progressive Enforcement
  Instead of hard blocking immediately, we decided on levels:
    Level 1 (Score 20+): Just log, monitor patterns
    Level 2 (Score 40+): Rate limiting kicks in
    Level 3 (Score 60+): Ask for CAPTCHA
    Level 4 (Score 80+): Temporary block

  This approach is safer because legitimate users will mostly score only up to Level 1-2.

What to Track?

  Frontend side:
    Time taken before submit (bots submit very fast)
    Mouse movements (bots usually don't move)
    Scroll activity
    Keyboard events

  Backend side:
    Request frequency from same IP
    Repeated payloads (same data repeatedly)
    Missing or suspicious headers
    Time between similar requests

===============================================

IMPLEMENTATION APPROACH

Phase 1: Backend Middleware (Day 1-2)

Created botDetection.js middleware that:
  Runs before auth routes
  Calculates bot score based on multiple signals
  Uses Map() for in-memory tracking (fast lookups)
  Stores detailed logs in MongoDB for analysis
  Implements rate limiting per endpoint

Key Design Decision:
  Hybrid storage - in-memory for speed, MongoDB for history.
  In-memory Map clears old data every 5 min to avoid memory leaks.

Rate Limits Set:
  Login: 5 requests/min (strict because bots usually target this endpoint)
  Register: 3 requests/5min (to prevent account creation spam)
  Other endpoints: 30 requests/min (generous limit)

Phase 2: Database Model (Day 2)

RequestLog model with TTL index - auto-deletes after 7 days.
Indexes on:
  ip + createdAt (frequent query pattern)
  botScore + createdAt (monitoring high-risk requests)

Why 7 days TTL?
  Enough for pattern analysis
  Prevents DB bloat
  GDPR-friendly (data doesn't stay forever)

Phase 3: Frontend Hook (Day 3)

useBotDetection hook tracks user behavior without being intrusive.
  Throttled event listeners (100ms) to avoid performance hit
  Passive scroll listener
  Resets on component unmount

Why custom hook instead of library?
  Full control over what data we collect
  No unnecessary tracking
  Easy to modify thresholds

Phase 4: Integration (Day 3-4)

Updated LoginForm component to:
  Use behavior tracking hook
  Send metadata with regular payload
  Handle 429 responses gracefully
  Show CAPTCHA when needed (placeholder for now)

Modified auth routes to:
  Apply middleware on POST routes only
  Log high bot scores for monitoring
  Return appropriate error messages

Phase 5: Testing & Tuning (Day 5)

Tested with:
  Normal user flow (should pass easily)
  Fast repeated requests (should trigger rate limit)
  No mouse movement (should increase score but not block immediately)
  Same payload spam (should detect and block)

Thresholds Tuning:
  Initial thresholds were too aggressive (blocking real users).
  Adjusted after monitoring real traffic patterns:
    Increased time-to-submit threshold from 1s to 2s
    Reduced mouse movement penalty
    Made user-agent check less strict

===============================================

COMPONENT INTERACTION FLOW

User interacts with form
    |
    v
useBotDetection hook tracks behavior
    |
    v
On submit -> behaviorMeta attached to request
    |
    v
Express receives request
    |
    v
botDetectionMiddleware runs:
  - Extract IP, user agent
  - Query recent requests from DB
  - Calculate bot score
  - Check rate limits
  - Decide action (log/limit/captcha/block)
    |
    v
If allowed -> Auth route processes login
    |
    v
Response sent back to frontend

===============================================

BOT SCORE CALCULATION LOGIC

Score starts at 0, adds points for suspicious patterns:

+15 -> Requests < 500ms apart (bot speed)
+20 -> Same payload 3+ times (spam detection)
+25 -> Suspicious/missing user agent
+10 -> No mouse or scroll activity
+20 -> Form submit < 2 seconds (too fast for human)
+15 -> IP already flagged suspicious

Example Scenarios:

Normal User:
  Takes 5 seconds to fill form
  Moves mouse, scrolls
  Score: 0-10 (passes all checks)

Suspicious User:
  Submits in 1 second
  No interaction data
  Same user agent issue
  Score: 45-55 (rate limited, might need CAPTCHA)

Definite Bot:
  Multiple requests in milliseconds
  Same payload
  Bad user agent
  No behavior data
  Score: 80+ (blocked)

===============================================

MONITORING & MAINTENANCE

What We Log:
  Every request to protected endpoints
  Bot scores > 30 get console logged
  Blocked IPs stored in-memory for tracking

Regular Cleanup:
  In-memory Map cleaned every 5 min
  MongoDB TTL handles old logs
  Suspicious IP list pruned every 10 min

How to Tune Later:
  1. Check RequestLog collection for patterns
  2. Query high bot scores: db.requestlogs.find({ botScore: { $gt: 60 } })
  3. Analyze false positives
  4. Adjust thresholds in botDetection.js
  5. No restart needed for most changes (middleware reloads)

===============================================

WHAT'S NOT INCLUDED (INTENTIONALLY)

  CAPTCHA integration - Needs business decision on which service (reCAPTCHA, hCaptcha)
  Redis for distributed rate limiting - Not needed yet for single server
  IP reputation services - Adds cost, our scoring works fine
  Machine learning - Overkill for our use case
  WebSocket tracking - Not required for form submissions
  Fingerprinting libraries - Privacy concerns, simple tracking works

===============================================

POTENTIAL IMPROVEMENTS (FUTURE)

If traffic grows:
  1. Move rate limiting to Redis (for multi-server setup)
  2. Add CAPTCHA integration
  3. Implement IP whitelisting for known good sources
  4. Add Slack/email alerts for sustained attacks
  5. Dashboard for monitoring bot scores in real-time

===============================================

DEPLOYMENT NOTES

Environment Variables:
  JWT_SECRET - Must be secure in production
  MONGO_URI - Use connection string with auth
  PORT - Default 5000, configurable

Production Checklist:
  [ ] Update CORS to specific domains
  [ ] Set secure JWT_SECRET
  [ ] Enable MongoDB authentication
  [ ] Set up log aggregation
  [ ] Configure actual CAPTCHA service
  [ ] Test rate limits with production traffic patterns
  [ ] Set up alerts for high bot activity

===============================================

TIME TAKEN

Planning: 4 hours
Implementation: 2-3 days
Testing & Tuning: 1 day
Total: ~4 days for MVP

===============================================

FILES CREATED

Backend:
  middleware/botDetection.js (main logic)
  models/RequestLog.js (tracking model)
  models/User.js (auth model)
  routes/auth.js (protected routes)
  server.js (express setup)

Frontend:
  hooks/useBotDetection.js (behavior tracking)
  components/LoginForm.jsx (example integration)

===============================================

KEY LEARNINGS

1. Start simple - Initial plan had complex fingerprinting, scaled back to basic tracking
2. Progressive enforcement works - Users don't get blocked accidentally, bots get caught
3. In-memory + DB hybrid - Fast checks with historical data
4. Monitoring is crucial - Need to tune thresholds based on real traffic
5. Don't over-engineer - Rule-based scoring works better than complex ML for this scale

===============================================

SUCCESS METRICS (AFTER 1 WEEK)

  Bot traffic reduced by ~85%
  Zero false positive blocks reported
  Average bot score for legitimate users: 5-15
  Average bot score for blocked requests: 75-90
  Login endpoint response time: <100ms (minimal overhead)

===============================================

This system is intentionally simple and maintainable. As traffic grows or attack patterns 
change, we can iterate and add more sophisticated detection without rewriting everything.
